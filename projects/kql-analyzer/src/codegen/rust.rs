use crate::hir::{HirProgram, HirStruct, HirEnum, HirType, PrimitiveType, HirId};
use crate::lir::SqlDialect;
use std::collections::BTreeMap;

pub struct RustGenerator {
    pub db: HirProgram,
    pub dialect: SqlDialect,
}

#[derive(Default)]
struct ModuleNode {
    submodules: BTreeMap<String, ModuleNode>,
    structs: Vec<HirId>,
    enums: Vec<HirId>,
}

impl RustGenerator {
    pub fn new(db: HirProgram, dialect: SqlDialect) -> Self {
        Self { db, dialect }
    }

    pub fn generate(&self) -> String {
        let mut out = String::new();
        out.push_str("// Generated by KQL. DO NOT EDIT.\n\n");
        out.push_str("use serde::{Serialize, Deserialize};\n");
        out.push_str("use sqlx::{FromRow, PgPool, MySqlPool, SqlitePool};\n\n");

        let mut root = ModuleNode::default();

        // Organize into tree
        for (id, s) in &self.db.structs {
            let node = self.get_module_node(&mut root, s.namespace.as_deref());
            node.structs.push(*id);
        }

        for (id, e) in &self.db.enums {
            let node = self.get_module_node(&mut root, e.namespace.as_deref());
            node.enums.push(*id);
        }

        self.gen_module(&mut out, &root, 0);

        out
    }

    fn get_module_node<'a>(&self, root: &'a mut ModuleNode, namespace: Option<&str>) -> &'a mut ModuleNode {
        let mut curr = root;
        if let Some(ns) = namespace {
            for part in ns.split("::") {
                curr = curr.submodules.entry(part.to_string()).or_default();
            }
        }
        curr
    }

    fn gen_module(&self, out: &mut String, node: &ModuleNode, indent: usize) {
        let indent_str = "    ".repeat(indent);

        // Sort for deterministic output
        let mut structs: Vec<_> = node.structs.iter().filter_map(|id| self.db.structs.get(id)).collect();
        structs.sort_by_key(|s| &s.name);

        let mut enums: Vec<_> = node.enums.iter().filter_map(|id| self.db.enums.get(id)).collect();
        enums.sort_by_key(|e| &e.name);

        for s in structs {
            out.push_str(&self.gen_struct(s, indent));
            out.push_str("\n");
            
            // Generate repository for tables
            let is_table = s.schema.is_some() || s.attrs.iter().any(|a| a.name == "table");
            if is_table {
                out.push_str(&self.gen_repository(s, indent));
                out.push_str("\n");
            }
        }

        for e in enums {
            out.push_str(&self.gen_enum(e, indent));
            out.push_str("\n");
        }

        for (name, sub) in &node.submodules {
            out.push_str(&format!("{}pub mod {} {{\n", indent_str, name));
            out.push_str(&format!("{}    use super::*;\n\n", indent_str));
            self.gen_module(out, sub, indent + 1);
            out.push_str(&format!("{}}}\n\n", indent_str));
        }
    }

    fn gen_struct(&self, s: &HirStruct, indent: usize) -> String {
        let indent_str = "    ".repeat(indent);
        let mut out = String::new();
        
        // Determine if this struct is a database table (has @schema or fields that are physical)
        let is_table = s.schema.is_some() || s.attrs.iter().any(|a| a.name == "table");

        if is_table {
            out.push_str(&format!("{}#[derive(Debug, Clone, Serialize, Deserialize, FromRow)]\n", indent_str));
        } else {
            out.push_str(&format!("{}#[derive(Debug, Clone, Serialize, Deserialize)]\n", indent_str));
        }

        out.push_str(&format!("{}pub struct {} {{\n", indent_str, s.name));
        for f in &s.fields {
            let rust_ty = self.gen_type(&f.ty);
            
            if is_table {
                match &f.ty {
                    HirType::Relation { .. } => {
                        out.push_str(&format!("{}    #[sqlx(skip)]\n", indent_str));
                    }
                    _ => {}
                }
            }

            out.push_str(&format!("{}    pub {}: {},\n", indent_str, f.name, rust_ty));
        }
        out.push_str(&format!("{}}}\n", indent_str));
        out
    }

    fn gen_enum(&self, e: &HirEnum, indent: usize) -> String {
        let indent_str = "    ".repeat(indent);
        let mut out = String::new();
        out.push_str(&format!("{}#[derive(Debug, Clone, Serialize, Deserialize)]\n", indent_str));
        out.push_str(&format!("{}pub enum {} {{\n", indent_str, e.name));
        for v in &e.variants {
            if let Some(fields) = &v.fields {
                out.push_str(&format!("{}    {} {{", indent_str, v.name));
                for f in fields {
                    out.push_str(&format!(" {}: {},", f.name, self.gen_type(&f.ty)));
                }
                out.push_str(" },\n");
            } else {
                out.push_str(&format!("{}    {},\n", indent_str, v.name));
            }
        }
        out.push_str(&format!("{}}}\n", indent_str));
        out
    }

    fn pool_name(&self) -> &str {
        match self.dialect {
            SqlDialect::Postgres => "PgPool",
            SqlDialect::MySql => "MySqlPool",
            SqlDialect::Sqlite => "SqlitePool",
        }
    }

    fn placeholder(&self, i: usize) -> String {
        match self.dialect {
            SqlDialect::Postgres => format!("${}", i),
            SqlDialect::MySql | SqlDialect::Sqlite => "?".to_string(),
        }
    }

    fn gen_repository(&self, s: &HirStruct, indent: usize) -> String {
        let indent_str = "    ".repeat(indent);
        let mut out = String::new();
        let repo_name = format!("{}Repository", s.name);
        let pool_name = self.pool_name();
        
        out.push_str(&format!("{}pub struct {} {{\n", indent_str, repo_name));
        out.push_str(&format!("{}    pool: {},\n", indent_str, pool_name));
        out.push_str(&format!("{}}}\n\n", indent_str));
        
        out.push_str(&format!("{}impl {} {{\n", indent_str, repo_name));
        out.push_str(&format!("{}    pub fn new(pool: {}) -> Self {{\n", indent_str, pool_name));
        out.push_str(&format!("{}        Self {{ pool }}\n", indent_str));
        out.push_str(&format!("{}    }}\n\n", indent_str));

        // Find primary key
        let pk_field = s.fields.iter().find(|f| {
            f.attrs.iter().any(|a| a.name == "primary_key") || matches!(f.ty, HirType::Key { .. })
        });

        if let Some(pk) = pk_field {
            let pk_ty = self.gen_type(&pk.ty);
            let p1 = self.placeholder(1);
            
            // Find method
            out.push_str(&format!("{}    pub async fn find(&self, id: {}) -> Result<Option<{}>, sqlx::Error> {{\n", indent_str, pk_ty, s.name));
            out.push_str(&format!("{}        sqlx::query_as::<_, {}>( \"SELECT * FROM {} WHERE {} = {}\")\n", indent_str, s.name, s.name.to_lowercase(), pk.name, p1));
            out.push_str(&format!("{}            .bind(id)\n", indent_str));
            out.push_str(&format!("{}            .fetch_optional(&self.pool)\n", indent_str));
            out.push_str(&format!("{}            .await\n", indent_str));
            out.push_str(&format!("{}    }}\n\n", indent_str));

            // Delete method
            out.push_str(&format!("{}    pub async fn delete(&self, id: {}) -> Result<(), sqlx::Error> {{\n", indent_str, pk_ty));
            out.push_str(&format!("{}        sqlx::query(\"DELETE FROM {} WHERE {} = {}\")\n", indent_str, s.name.to_lowercase(), pk.name, p1));
            out.push_str(&format!("{}            .bind(id)\n", indent_str));
            out.push_str(&format!("{}            .execute(&self.pool)\n", indent_str));
            out.push_str(&format!("{}            .await?;\n", indent_str));
            out.push_str(&format!("{}        Ok(())\n", indent_str));
            out.push_str(&format!("{}    }}\n\n", indent_str));
        }

        // Insert method
        let insert_fields: Vec<_> = s.fields.iter()
            .filter(|f| !f.auto_increment() && !matches!(f.ty, HirType::Relation { .. }))
            .collect();
        
        if !insert_fields.is_empty() {
            let field_names: Vec<_> = insert_fields.iter().map(|f| f.name.as_str()).collect();
            let placeholders: Vec<_> = (1..=insert_fields.len()).map(|i| self.placeholder(i)).collect();
            
            out.push_str(&format!("{}    pub async fn insert(&self, model: &{}) -> Result<(), sqlx::Error> {{\n", indent_str, s.name));
            out.push_str(&format!("{}        sqlx::query(\"INSERT INTO {} ({}) VALUES ({})\")\n", 
                indent_str, 
                s.name.to_lowercase(), 
                field_names.join(", "), 
                placeholders.join(", ")
            ));
            for f in insert_fields {
                out.push_str(&format!("{}            .bind(&model.{})\n", indent_str, f.name));
            }
            out.push_str(&format!("{}            .execute(&self.pool)\n", indent_str));
            out.push_str(&format!("{}            .await?;\n", indent_str));
            out.push_str(&format!("{}        Ok(())\n", indent_str));
            out.push_str(&format!("{}    }}\n\n", indent_str));
        }

        // Update method
        if let Some(pk) = pk_field {
            let update_fields: Vec<_> = s.fields.iter()
                .filter(|f| f.name != pk.name && !matches!(f.ty, HirType::Relation { .. }))
                .collect();
            
            if !update_fields.is_empty() {
                let mut sets = Vec::new();
                for (i, f) in update_fields.iter().enumerate() {
                    sets.push(format!("{} = {}", f.name, self.placeholder(i + 1)));
                }
                
                out.push_str(&format!("{}    pub async fn update(&self, model: &{}) -> Result<(), sqlx::Error> {{\n", indent_str, s.name));
                out.push_str(&format!("{}        sqlx::query(\"UPDATE {} SET {} WHERE {} = {}\")\n", 
                    indent_str, 
                    s.name.to_lowercase(), 
                    sets.join(", "), 
                    pk.name,
                    self.placeholder(update_fields.len() + 1)
                ));
                for f in &update_fields {
                    out.push_str(&format!("{}            .bind(&model.{})\n", indent_str, f.name));
                }
                out.push_str(&format!("{}            .bind(&model.{})\n", indent_str, pk.name));
                out.push_str(&format!("{}            .execute(&self.pool)\n", indent_str));
                out.push_str(&format!("{}            .await?;\n", indent_str));
                out.push_str(&format!("{}        Ok(())\n", indent_str));
                out.push_str(&format!("{}    }}\n\n", indent_str));
            }
        }

        // List method
        out.push_str(&format!("{}    pub async fn list(&self) -> Result<Vec<{}>, sqlx::Error> {{\n", indent_str, s.name));
        out.push_str(&format!("{}        sqlx::query_as::<_, {}>( \"SELECT * FROM {}\")\n", indent_str, s.name, s.name.to_lowercase()));
        out.push_str(&format!("{}            .fetch_all(&self.pool)\n", indent_str));
        out.push_str(&format!("{}            .await\n", indent_str));
        out.push_str(&format!("{}    }}\n", indent_str));

        out.push_str(&format!("{}}}\n", indent_str));
        out
    }

    fn gen_type(&self, ty: &HirType) -> String {
        match ty {
            HirType::Primitive(p) => match p {
                PrimitiveType::I32 => "i32".to_string(),
                PrimitiveType::I64 => "i64".to_string(),
                PrimitiveType::F32 => "f32".to_string(),
                PrimitiveType::F64 => "f64".to_string(),
                PrimitiveType::String => "String".to_string(),
                PrimitiveType::Bool => "bool".to_string(),
                PrimitiveType::DateTime => "chrono::DateTime<chrono::Utc>".to_string(),
                PrimitiveType::Uuid => "uuid::Uuid".to_string(),
                PrimitiveType::D128 => "rust_decimal::Decimal".to_string(),
            },
            HirType::Struct(id) => self.db.structs.get(id).map(|s| s.name.clone()).unwrap_or_else(|| "UnknownStruct".to_string()),
            HirType::Enum(id) => self.db.enums.get(id).map(|e| e.name.clone()).unwrap_or_else(|| "UnknownEnum".to_string()),
            HirType::List(inner) => format!("Vec<{}>", self.gen_type(inner)),
            HirType::Optional(inner) => format!("Option<{}>", self.gen_type(inner)),
            HirType::Key { inner, .. } => self.gen_type(inner),
            HirType::ForeignKey { entity, .. } => {
                if let Some(s) = self.db.structs.get(entity) {
                    // Look for the field marked as Key
                    for f in &s.fields {
                        if let HirType::Key { inner, .. } = &f.ty {
                            return self.gen_type(inner);
                        }
                    }
                    // Fallback to "id" field if no Key is found
                    for f in &s.fields {
                        if f.name == "id" {
                            return self.gen_type(&f.ty);
                        }
                    }
                }
                "i32".to_string()
            }
            HirType::Relation { target, is_list, .. } => {
                let target_name = self.db.structs.get(target).map(|s| s.name.clone()).unwrap_or_else(|| "UnknownStruct".to_string());
                if *is_list {
                    format!("Vec<{}>", target_name)
                } else {
                    format!("Option<{}>", target_name)
                }
            }
            HirType::Null => "()".to_string(),
            HirType::Unknown => "()".to_string(),
        }
    }
}
