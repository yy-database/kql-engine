use crate::hir::{HirProgram, HirStruct, HirEnum, HirType, PrimitiveType};
use std::collections::BTreeMap;

pub struct RustGenerator {
    pub db: HirProgram,
}

#[derive(Default)]
struct ModuleNode {
    submodules: BTreeMap<String, ModuleNode>,
    structs: Vec<HirId>,
    enums: Vec<HirId>,
}

use crate::hir::HirId;

impl RustGenerator {
    pub fn new(db: HirProgram) -> Self {
        Self { db }
    }

    pub fn generate(&self) -> String {
        let mut out = String::new();
        out.push_str("// Generated by KQL. DO NOT EDIT.\n\n");
        out.push_str("use serde::{Serialize, Deserialize};\n\n");

        let mut root = ModuleNode::default();

        // Organize into tree
        for (id, s) in &self.db.structs {
            let node = self.get_module_node(&mut root, s.namespace.as_deref());
            node.structs.push(*id);
        }

        for (id, e) in &self.db.enums {
            let node = self.get_module_node(&mut root, e.namespace.as_deref());
            node.enums.push(*id);
        }

        self.gen_module(&mut out, &root, 0);

        out
    }

    fn get_module_node<'a>(&self, root: &'a mut ModuleNode, namespace: Option<&str>) -> &'a mut ModuleNode {
        let mut curr = root;
        if let Some(ns) = namespace {
            for part in ns.split("::") {
                curr = curr.submodules.entry(part.to_string()).or_default();
            }
        }
        curr
    }

    fn gen_module(&self, out: &mut String, node: &ModuleNode, indent: usize) {
        let indent_str = "    ".repeat(indent);

        // Sort for deterministic output
        let mut structs: Vec<_> = node.structs.iter().filter_map(|id| self.db.structs.get(id)).collect();
        structs.sort_by_key(|s| &s.name);

        let mut enums: Vec<_> = node.enums.iter().filter_map(|id| self.db.enums.get(id)).collect();
        enums.sort_by_key(|e| &e.name);

        for s in structs {
            out.push_str(&self.gen_struct(s, indent));
            out.push_str("\n");
        }

        for e in enums {
            out.push_str(&self.gen_enum(e, indent));
            out.push_str("\n");
        }

        for (name, sub) in &node.submodules {
            out.push_str(&format!("{}pub mod {} {{\n", indent_str, name));
            out.push_str(&format!("{}    use super::*;\n\n", indent_str));
            self.gen_module(out, sub, indent + 1);
            out.push_str(&format!("{}}}\n\n", indent_str));
        }
    }

    fn gen_struct(&self, s: &HirStruct, indent: usize) -> String {
        let indent_str = "    ".repeat(indent);
        let mut out = String::new();
        out.push_str(&format!("{}#[derive(Debug, Clone, Serialize, Deserialize)]\n", indent_str));
        out.push_str(&format!("{}pub struct {} {{\n", indent_str, s.name));
        for f in &s.fields {
            let rust_ty = self.gen_type(&f.ty);
            out.push_str(&format!("{}    pub {}: {},\n", indent_str, f.name, rust_ty));
        }
        out.push_str(&format!("{}}}\n", indent_str));
        out
    }

    fn gen_enum(&self, e: &HirEnum, indent: usize) -> String {
        let indent_str = "    ".repeat(indent);
        let mut out = String::new();
        out.push_str(&format!("{}#[derive(Debug, Clone, Serialize, Deserialize)]\n", indent_str));
        out.push_str(&format!("{}pub enum {} {{\n", indent_str, e.name));
        for v in &e.variants {
            if let Some(fields) = &v.fields {
                out.push_str(&format!("{}    {} {{", indent_str, v.name));
                for f in fields {
                    out.push_str(&format!(" {}: {},", f.name, self.gen_type(&f.ty)));
                }
                out.push_str(" },\n");
            } else {
                out.push_str(&format!("{}    {},\n", indent_str, v.name));
            }
        }
        out.push_str(&format!("{}}}\n", indent_str));
        out
    }

    fn gen_type(&self, ty: &HirType) -> String {
        match ty {
            HirType::Primitive(p) => match p {
                PrimitiveType::I32 => "i32".to_string(),
                PrimitiveType::I64 => "i64".to_string(),
                PrimitiveType::F32 => "f32".to_string(),
                PrimitiveType::F64 => "f64".to_string(),
                PrimitiveType::String => "String".to_string(),
                PrimitiveType::Bool => "bool".to_string(),
                PrimitiveType::DateTime => "chrono::DateTime<chrono::Utc>".to_string(),
                PrimitiveType::Uuid => "uuid::Uuid".to_string(),
                PrimitiveType::D128 => "rust_decimal::Decimal".to_string(),
            },
            HirType::Struct(id) => self.db.structs.get(id).map(|s| s.name.clone()).unwrap_or_else(|| "UnknownStruct".to_string()),
            HirType::Enum(id) => self.db.enums.get(id).map(|e| e.name.clone()).unwrap_or_else(|| "UnknownEnum".to_string()),
            HirType::List(inner) => format!("Vec<{}>", self.gen_type(inner)),
            HirType::Optional(inner) => format!("Option<{}>", self.gen_type(inner)),
            HirType::Key { inner, .. } => self.gen_type(inner),
            HirType::ForeignKey { entity, .. } => {
                if let Some(s) = self.db.structs.get(entity) {
                    for f in &s.fields {
                        if f.name == "id" {
                            return self.gen_type(&f.ty);
                        }
                    }
                }
                "i32".to_string()
            }
            HirType::Null => "()".to_string(),
            HirType::Unknown => "()".to_string(),
        }
    }
}
