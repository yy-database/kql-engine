use crate::hir::{HirProgram, HirStruct, HirEnum, HirType, PrimitiveType};

pub struct RustGenerator {
    pub db: HirProgram,
}

impl RustGenerator {
    pub fn new(db: HirProgram) -> Self {
        Self { db }
    }

    pub fn generate(&self) -> String {
        let mut out = String::new();
        out.push_str("// Generated by KQL. DO NOT EDIT.\n\n");
        out.push_str("use serde::{Serialize, Deserialize};\n\n");

        // Sort by name for deterministic output
        let mut structs: Vec<_> = self.db.structs.values().collect();
        structs.sort_by_key(|s| &s.name);

        let mut enums: Vec<_> = self.db.enums.values().collect();
        enums.sort_by_key(|e| &e.name);

        for s in structs {
            out.push_str(&self.gen_struct(s));
            out.push_str("\n");
        }

        for e in enums {
            out.push_str(&self.gen_enum(e));
            out.push_str("\n");
        }

        out
    }

    fn gen_struct(&self, s: &HirStruct) -> String {
        let mut out = String::new();
        out.push_str("#[derive(Debug, Clone, Serialize, Deserialize)]\n");
        out.push_str(&format!("pub struct {} {{\n", s.name));
        for f in &s.fields {
            let rust_ty = self.gen_type(&f.ty);
            out.push_str(&format!("    pub {}: {},\n", f.name, rust_ty));
        }
        out.push_str("}\n");
        out
    }

    fn gen_enum(&self, e: &HirEnum) -> String {
        let mut out = String::new();
        out.push_str("#[derive(Debug, Clone, Serialize, Deserialize)]\n");
        out.push_str(&format!("pub enum {} {{\n", e.name));
        for v in &e.variants {
            if let Some(fields) = &v.fields {
                out.push_str(&format!("    {} {{", v.name));
                for f in fields {
                    out.push_str(&format!(" {}: {},", f.name, self.gen_type(&f.ty)));
                }
                out.push_str(" },\n");
            } else {
                out.push_str(&format!("    {},\n", v.name));
            }
        }
        out.push_str("}\n");
        out
    }

    fn gen_type(&self, ty: &HirType) -> String {
        match ty {
            HirType::Primitive(p) => match p {
                PrimitiveType::I32 => "i32".to_string(),
                PrimitiveType::I64 => "i64".to_string(),
                PrimitiveType::F32 => "f32".to_string(),
                PrimitiveType::F64 => "f64".to_string(),
                PrimitiveType::String => "String".to_string(),
                PrimitiveType::Bool => "bool".to_string(),
                PrimitiveType::DateTime => "chrono::DateTime<chrono::Utc>".to_string(),
                PrimitiveType::Uuid => "uuid::Uuid".to_string(),
                PrimitiveType::D128 => "rust_decimal::Decimal".to_string(),
            },
            HirType::Struct(id) => self.db.structs.get(id).map(|s| s.name.clone()).unwrap_or_else(|| "UnknownStruct".to_string()),
            HirType::Enum(id) => self.db.enums.get(id).map(|e| e.name.clone()).unwrap_or_else(|| "UnknownEnum".to_string()),
            HirType::List(inner) => format!("Vec<{}>", self.gen_type(inner)),
            HirType::Optional(inner) => format!("Option<{}>", self.gen_type(inner)),
            HirType::Key { inner, .. } => self.gen_type(inner),
            HirType::Unknown => "()".to_string(),
        }
    }
}
